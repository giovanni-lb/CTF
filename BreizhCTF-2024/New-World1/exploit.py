from pwn import *
from unicorn import *
from unicorn.x86_const import *
from unicorn.arm_const import *
from unicorn.arm64_const import *
from capstone import *
import binascii

def init_unicorn(arch):
    arch_dict = {
        'x86': (UC_ARCH_X86, UC_MODE_32),
        'x64': (UC_ARCH_X86, UC_MODE_64),
        'ARM32': (UC_ARCH_ARM, UC_MODE_ARM),
        'AArch64': (UC_ARCH_ARM64, UC_MODE_ARM)
    }
    if arch in arch_dict:
        return Uc(*arch_dict[arch])
    else:
        raise ValueError(f"Architecture not implemented: {arch}")


def read_registers(mu, arch):
    reg_map = {
        'x86': [UC_X86_REG_EAX, UC_X86_REG_EBX, UC_X86_REG_ECX, UC_X86_REG_EDX],
        'x64': [UC_X86_REG_RAX, UC_X86_REG_RBX, UC_X86_REG_RCX, UC_X86_REG_RDX],
        'ARM32': [UC_ARM_REG_R0, UC_ARM_REG_R1, UC_ARM_REG_R2, UC_ARM_REG_R3, UC_ARM_REG_R4, UC_ARM_REG_R5, UC_ARM_REG_R6, UC_ARM_REG_R7, UC_ARM_REG_R8, UC_ARM_REG_R9],
        'AArch64': [UC_ARM64_REG_X8, UC_ARM64_REG_X9, UC_ARM64_REG_X10, UC_ARM64_REG_X11, UC_ARM64_REG_X12, UC_ARM64_REG_X13, UC_ARM64_REG_X14, UC_ARM64_REG_X15]
    }
    return tuple(mu.reg_read(reg) for reg in reg_map.get(arch, []))

def format(value):
    if value == 0:
        return "0x00"
    elif value <= 0xff:
        return f"0x{value:02x}"
    elif value <= 0xfff:
        return f"0x{value:03x}"
    else:
        return f"0x{value:04x}"

def emulate(code, arch):
    ADDRESS = 0x10000

    mu = init_unicorn(arch)
    mu.mem_map(ADDRESS, 4 * 1024 * 1024)
    mu.mem_write(ADDRESS, shellcode)

    mu.emu_start(ADDRESS, ADDRESS + len(code))

    return read_registers(mu, arch)

io = remote("challenge.ctf.bzh", 31986)

for i in range(15):
    print(f"Etape : [{i + 1}/15]")
    io.recvuntil(b"registres ")
    reg = io.recvuntil(b"apr").split(b"apr")[0].strip()
    print(reg)
    reg = reg.split(b',')
    io.recvuntil(b"code assembleur ")

    arch = io.recvuntil(b"suivant :").split(b" ")[0].strip().decode()
    bc = io.recvuntil(b"\n").strip()

    code = binascii.unhexlify(bc.replace(b'\\x', b''))
    reg_out = emulate(code, arch)

    payload = ""

    if arch in ["x86", "x64"]:
        reg_names = ["ax", "bx", "cx", "dx"]
    elif arch == "ARM32":
        reg_names = [f"r{i}" for i in range(10)]
    elif arch == "AArch64":
        reg_names = [f"x{i}" for i in range(8, 16)]

    for r in reg:
        for i, name in enumerate(reg_names):
            if name.encode() in r:
                payload += format(reg_out[i]) + ","

    payload = payload[:-1]
    print(payload)
    io.sendline(payload.encode())

print(io.recvline().decode())
